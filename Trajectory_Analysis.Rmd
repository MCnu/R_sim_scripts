---
title: "Figures"
output: html_document
author: "Michael Chas Sumner"
---

## chunk0.1, setup packages and root.dir

```{r setup, include = F}

pull_dir = "C:/users/bjbsu/Desktop/PULLS/R_sim_scripts/"


require(stats)

require(data.table)

require(tidyverse)

require(gganimate)

require(viridis)

require(knitr)

require(gridExtra)

source(paste(pull_dir, "Simulated_MSD.R", sep=""), echo=FALSE)

source(paste(pull_dir, "smoothMSD.R", sep=""), echo=FALSE)

source(paste(pull_dir, "SimLin_Repos.R", sep=""), echo=FALSE)

uap = "U3alonePlus"
gup = "G1atU3Plus"

comtheme <- theme_bw() +
  theme(text = element_text(color = "#545454", size = 18),
        legend.position = "none")

#set this to the raw_data directory
opts_knit$set(root.dir = paste(pull_dir, "data/Analytical_environment/raw_data", sep=""))


```




## chunk1, create list of trajectories as matrices

## if Debuffer = True, the matrices will be cropped to the size defined in
debuff_end and debuff_start

```{r, echo=F}

#Controls wheter you cut off the first specified number of steps for each trajectory
Debuffer = F


list.files()

#specify the directory containing trajectory .csv files
setwd(list.files()[3])

list_source_wd <- getwd() %>% strsplit("/") %>% unlist()
list_source_wd <- list_source_wd[length(list_source_wd)]

print(list_source_wd)

for (i in 1:length(list.files())) {
  if (i == 1) {
    sim_list <- vector(mode = "list", length = length(list.files()))
  }
  sim_list[[i]] <- as.matrix(fread(list.files()[i]))
}

if (Debuffer == T){
  debuff_sim_list <- vector("list", length = length(sim_list))
  debuff_end <- nrow(sim_list[[1]])
  debuff_start <- debuff_end - 3000
  
  for (i in 1:length(sim_list)) {
    debuff_sim_list[[i]] <- sim_list[[i]][debuff_start:debuff_end, ]
    
  }
  
  start_x <- c()
  start_y <- c()
  for (i in 1:length(debuff_sim_list)) {
    start_x <- c(start_x, debuff_sim_list[[i]][1, 1])
    start_y <- c(start_y, debuff_sim_list[[i]][1, 2])
  }
  
  start_frame <- data.frame(ID = seq(1,length(start_x),1),x = start_x, 
                            y = start_y, rad = sqrt(start_x^2 + start_y^2))
  
  
  shist_plot <- ggplot(data=start_frame)+
    geom_histogram(aes(x=rad), bins = 10)+
    comtheme+
    labs(title = "Start Position Radii")
  
  spos_plot <- ggplot(data = start_frame)+
    geom_point(aes(x=x,y=y))+
    comtheme+
    labs(title = "Start Positions")
  
  sx_plot <- ggplot(data = start_frame)+
    geom_histogram(aes(x=x), bins = 10)+
    comtheme+
    labs(title = "Start X")
  
  sy_plot <- ggplot(data = start_frame)+
    geom_histogram(aes(x=y), bins = 10)+
    comtheme+
    labs(title = "Start Y")
  
  
  end_x <- c()
  end_y <- c()
  for (i in 1:length(debuff_sim_list)) {
    end_x <- c(end_x, debuff_sim_list[[i]][nrow(debuff_sim_list[[i]]), 1])
    end_y <- c(end_y, debuff_sim_list[[i]][nrow(debuff_sim_list[[i]]), 2])
  }
  
  end_frame <- data.frame(ID = seq(1,length(end_x),1),x = end_x, y = end_y, rad = sqrt(end_x^2 + end_y^2))
  
  ehist_plot <- ggplot(data=end_frame)+
    geom_histogram(aes(x=rad), bins = 10)+
    comtheme+
    labs(title = "End Position Radii")
  
  epos_plot <- ggplot(data = end_frame)+
    geom_point(aes(x=x,y=y))+
    comtheme+
    labs(title = "End Positions")
  
  ex_plot <- ggplot(data = end_frame)+
    geom_histogram(aes(x=x), bins = 10)+
    comtheme+
    labs(title = "End X")
  
  ey_plot <- ggplot(data = end_frame)+
    geom_histogram(aes(x=y), bins = 10)+
    comtheme+
    labs(title = "End Y")

}else{
    
  start_x <- c()
  start_y <- c()
  for (i in 1:length(sim_list)) {
    start_x <- c(start_x, sim_list[[i]][1, 1])
    start_y <- c(start_y, sim_list[[i]][1, 2])
  }
  
  start_frame <- data.frame(ID = seq(1,length(start_x),1),x = start_x, 
                            y = start_y, rad = sqrt(start_x^2 + start_y^2))
  
  shist_plot <- ggplot(data=start_frame)+
    geom_histogram(aes(x=rad), bins = 10)+
    comtheme+
    labs(title = "Start Position Radii")
  
  spos_plot <- ggplot(data = start_frame)+
    geom_point(aes(x=x,y=y))+
    comtheme+
    labs(title = "Start Positions")
  
  sx_plot <- ggplot(data = start_frame)+
    geom_histogram(aes(x=x), bins = 10)+
    comtheme+
    labs(title = "Start X")
  
  sy_plot <- ggplot(data = start_frame)+
    geom_histogram(aes(x=y), bins = 10)+
    comtheme+
    labs(title = "Start Y")
  
  
  end_x <- c()
  end_y <- c()
  for (i in 1:length(sim_list)) {
    end_x <- c(end_x, sim_list[[i]][nrow(sim_list[[i]]), 1])
    end_y <- c(end_y, sim_list[[i]][nrow(sim_list[[i]]), 2])
  }
  
  end_frame <- data.frame(ID = seq(1,length(end_x),1),x = end_x, y = end_y, rad = sqrt(end_x^2 + end_y^2))
  
  ehist_plot <- ggplot(data=end_frame)+
    geom_histogram(aes(x=rad), bins = 10)+
    comtheme+
    labs(title = "End Position Radii")
  
  epos_plot <- ggplot(data = end_frame)+
    geom_point(aes(x=x,y=y))+
    comtheme+
    labs(title = "End Positions")
  
  ex_plot <- ggplot(data = end_frame)+
    geom_histogram(aes(x=x), bins = 10)+
    comtheme+
    labs(title = "End X")
  
  ey_plot <- ggplot(data = end_frame)+
    geom_histogram(aes(x=y))+
    comtheme+
    labs(title = "End Y")
}

grid.arrange(shist_plot,spos_plot,ehist_plot,epos_plot)

grid.arrange(sx_plot,sy_plot,ex_plot,ey_plot)

```


## chunk3, create a more robust data set w/ dist to start, to previous, and to 
origin

##Dependent on chunk1

```{r, echo = F}

time_interval = 0.21

TBF <- sim_list
subTBF_nrow <- length(TBF[[1]][, 1])
time_seq <- matrix(seq(0, (subTBF_nrow - 1) * time_interval, time_interval), ncol = 1)
for (i in 1:length(TBF)) {
  TBF[[i]] <- cbind(TBF[[i]], time_seq)
  colnames(TBF[[i]]) <- c("x", "y", "is_bound", "time")
}

t_int <- TBF[[1]][, "time"][2]
d2svec <- c(0)
d2pvec <- c(0)
d2ovec <- c(0)
tot_d2o <- c()
d2_list <- vector("list", length(TBF))

for (i in 1:length(TBF)) {
  float_mat <- TBF[[i]]
  d2ovec[1] <- sqrt(float_mat[1, 1] ^ 2 + float_mat[1, 2] ^ 2)
  for (j in 2:nrow(float_mat)) {
    d2svec[j] <-
      sqrt((float_mat[1, 1] - float_mat[j, 1]) ^ 2 + (float_mat[1, 2] - float_mat[j, 2]) ^
             2)
    d2pvec[j] <-
      sqrt((float_mat[(j - 1), 1] - float_mat[j, 1]) ^ 2 + (float_mat[(j - 1), 2] - float_mat[j, 2]) ^
             2)
    d2ovec[j] <- sqrt(float_mat[j, 1] ^ 2 + float_mat[j, 2] ^ 2)
  }
  float_mat <-
    cbind(float_mat,
          matrix(d2svec, ncol = 1),
          matrix(d2pvec, ncol = 1),
          matrix(d2ovec, ncol = 1))
  colnames(float_mat) <-
    c("x", "y", "is_bound", "time", "D2P", "D2S", "D2O")
  row.names(float_mat) <- c(1:nrow(float_mat))
  d2_list[[i]] <- float_mat
  tot_d2o <- c(tot_d2o, d2ovec)
}

plot(density(tot_d2o, from = 0, to = max(tot_d2o)))

```




## Chunk 4, visualize frequency of peripheral occupancy

## Dependent on chunk3
```{r, echo = F}
periph_occu_list <- vector("list", length(d2_list))
bound_zone_thickness <-
  (1 - sqrt(2 / 3)) # this is outer third of nucleus

#TODO maybe make binning a function? to apply across the list
bin_to_10sec = FALSE

for (i in 1:length(d2_list)) {
  float_po_logic <- d2_list[[i]][, "D2O"] > (1 - bound_zone_thickness)
  float_po_matrix <-
    matrix(seq(0, (length(float_po_logic) - 1) * time_interval, time_interval), ncol = 1)
  periph_occu_list[[i]] <-
    cbind(float_po_matrix, matrix(as.numeric(float_po_logic), ncol = 1))
}

preproc_NAs <-
  
  rep(NA, (length(periph_occu_list[[i]][, 1]) * length(periph_occu_list)))
po_plot_frame <-
  data.frame(Trajectory = preproc_NAs,
             time = preproc_NAs,
             is_periph = preproc_NAs)

for (i in 1:length(periph_occu_list)) {
  po_plot_frame[((i - 1) * nrow(periph_occu_list[[i]]) + 1):(i * nrow(periph_occu_list[[i]])), ] <-
    data.frame(Trajectory = i,
               time = periph_occu_list[[i]][, 1],
               is_periph = periph_occu_list[[i]][, 2])
}

if (bin_to_10sec){
  #set how many steps make up one bin
  size_of_bin = 10 / time_interval
  
  preproc_NAs <- rep(NA, (length(po_plot_frame[, 1]) / size_of_bin))
  bin_po_plot_frame <-
    data.frame(Trajectory = preproc_NAs,
               time = preproc_NAs,
               is_periph = preproc_NAs)
  for (i in 1:length(bin_po_plot_frame[, 1])) {
    bin_po_plot_frame[i, 1] <-
      mean(po_plot_frame[((i - 1) * size_of_bin + 1):(i * size_of_bin), 1])
    bin_po_plot_frame[i, 2] <- po_plot_frame[((i - 1) * size_of_bin + 1), 2]
    bin_po_plot_frame[i, 3] <-
      round(mean(po_plot_frame[((i - 1) * size_of_bin + 1):(i * size_of_bin), 3]))
  }
  
  
  bpo_boundfrac_traj <- c()
  for (i in 1:length(unique(bin_po_plot_frame[, 1]))) {
    bpo_boundfrac_traj[i] <-
      mean(bin_po_plot_frame[(bin_po_plot_frame[, 1] == unique(bin_po_plot_frame[, 1])[i]), 3])
  }
  
  ordered_bpopf <- bin_po_plot_frame
  ordered_bpopf <- mutate(ordered_bpopf, rank = NA)
  for (i in 1:length(bpo_boundfrac_traj)) {
    float_frame <-
      filter(bin_po_plot_frame, Trajectory == (order(bpo_boundfrac_traj)[i]))
    ordered_bpopf[((i - 1) * nrow(float_frame) + 1):(i * nrow(float_frame)), 1:3] <-
      float_frame
    ordered_bpopf[((i - 1) * nrow(float_frame) + 1):(i * nrow(float_frame)), 4] <-
      i
  }
  
  obpo_plot <- ggplot(data = ordered_bpopf) +
    geom_tile(aes(
      x = time,
      y = rank,
      color = is_periph,
      fill = is_periph
    ),
    position = "dodge") +
    theme(legend.position = "none") +
    scale_colour_viridis() +
    scale_fill_viridis() +
    comtheme
  
  print(obpo_plot)
  
  bpo_boundfrac_time <- c()
  for (i in 1:length(unique(bin_po_plot_frame[, 2]))) {
    bpo_boundfrac_time[i] <-
      mean(bin_po_plot_frame[(bin_po_plot_frame[, 2] == unique(bin_po_plot_frame[, 2])[i]), 3])
  }
  
  bpobf_time_frame <-
    data.frame(bound_frac = bpo_boundfrac_time, time = c((1:length(bpo_boundfrac_time)) * (time_interval * size_of_bin)))
  
  ggplot(data = bpobf_time_frame) +
    stat_smooth(aes(x = time, y = bound_frac * 100)) +
    geom_point(aes(x = time, y = bound_frac * 100), alpha = 0.5) +
    coord_cartesian(ylim = c(0, 100)) +
    comtheme +
    ylab("% of Trajectories at the periphery") +
    xlab("time (s)")
  
}else{
  
  time_nrow <- length(unique(po_plot_frame$time))
  
  if(time_nrow > 5000){time_nrow = 5000}
  
  float_time_interval <- po_plot_frame$time[2] - po_plot_frame$time[1]
  
  mpp_frame <- po_plot_frame[po_plot_frame$time <= (float_time_interval*time_nrow),]
  
  order_mat <- matrix(nrow = length(unique(mpp_frame$Trajectory)), ncol = 2)
  
  for(i in 1:length(unique(mpp_frame$Trajectory))){
    float_pot <- mean(mpp_frame[mpp_frame$Trajectory==(unique(mpp_frame$Trajectory)[i]),"is_periph"])
    order_mat[i,] <- c(i,float_pot)
    
  }
  
  new_order <- order(order_mat[,2])
  
  nompp_frame <- mutate(mpp_frame, rank = NA)
  
  for(i in 1:length(unique(mpp_frame$Trajectory))){
    temp_traj <- mpp_frame[mpp_frame$Trajectory == new_order[i],]
    nompp_frame[(((i-1)*nrow(temp_traj))+1):(i*nrow(temp_traj)),-(ncol(nompp_frame))] <- temp_traj
    nompp_frame[(((i-1)*nrow(temp_traj))+1):(i*nrow(temp_traj)),(ncol(nompp_frame))] <- i
    
  }
  
  po_plot <- ggplot(data = nompp_frame) +
    geom_tile(aes(
      x = time,
      y = rank,
      color = is_periph,
      fill = is_periph
    ),
    position = "dodge") +
    theme(legend.position = "none") +
    scale_colour_viridis() +
    scale_fill_viridis() +
    coord_cartesian(xlim = c(0,(float_time_interval * time_nrow)))+
    comtheme
  
  
  po_avg_time_frame <- data.frame(time = rep(NA,time_nrow), bound_frac = rep(NA,time_nrow))
  
  for(i in 1:time_nrow){
    cur_time <- float_time_interval * (i-1)
    po_avg_time_frame[i,1] <- cur_time
    po_avg_time_frame[i,2] <- mean(mpp_frame[mpp_frame$time == cur_time,]$is_periph)
    
  }
  
  pat_plot <- ggplot(data=po_avg_time_frame)+
    geom_point(aes(x = time, y = bound_frac * 100), alpha = 0.1) +
    stat_smooth(aes(x = time, y = bound_frac * 100)) +
    coord_cartesian(ylim = c(0, 100)) +
    comtheme +
    ylab("% of Trajectories at the periphery") +
    xlab("time (s)")
  
}

print(list_source_wd)

```


## chunk2, create list of last 200 steps in trajectory, quantify MSD, plot MSD, 
and merge

##Dependent on chunk1

```{r MSD, echo=F, message=FALSE}
for (i in 1:length(sim_list)) {
  if (i == 1) {
    msd_list <- vector(mode = "list", length = length(sim_list))
  }
  sl_len <- length(sim_list[[i]][, 1])
  msd_list[[i]] <- sim_list[[i]][((sl_len - 199):sl_len), ]
}


simMSD(msd_list, list_source_wd)
kurzplot(list_source_wd)
```



##chunk5, repositioning
##

```{r Repositioning}
Repos_List <- d2_list
sim_lin()

tvv_frame <- data.frame(velocity = tvv)

mdd_plot <- ggplot(data = global_direct_sim)+
  geom_histogram(aes(x=delta_dist), bins = 30)+
  comtheme

mdt_plot <- ggplot(data=global_summary_sim)+
  geom_density(aes(x=mean_delta_theta))+
  comtheme

time_plot <- ggplot(data = global_summary_sim)+
  geom_density(aes(x = time))+
  comtheme

velo_plot <- ggplot(data = tvv_frame)+
  geom_histogram(aes(x = velocity), bins = 30)+
  comtheme

grid.arrange(velo_plot,time_plot,mdt_plot,mdd_plot)

```


##chunk 6, clusters

##Dependent on

```{r Clusters}
#randomize simlist into two pairwise lists

d2_list_length <- length(d2_list)

rand_d2 <- seq(1,d2_list_length,1)

#peroform cluster component analysis on the two lists in a pairwise fashion

```

##chunck animate

#dependent on d2_list

```{r Animate}
setwd("../images")

save_product = TRUE

fname = list_source_wd

d2len <- length(d2_list)
d2len = 25
d2nrow <- nrow(d2_list[[1]])
d2nrow = 10000
d2ncol <- ncol(d2_list[[1]])

big_float_mat <- matrix(ncol = d2ncol + 1, nrow = d2nrow * d2len)

for(i in 1:d2len){
  big_float_mat[((i-1) * d2nrow + 1) : (i * d2nrow), -(d2ncol+1)] <- d2_list[[i]][1:d2nrow,1:d2ncol]
  big_float_mat[((i-1) * d2nrow + 1) : (i * d2nrow), d2ncol+1] <-
     rep(i,d2nrow)
  
}

float_frame <- as.data.frame(big_float_mat)

colnames(float_frame) <- c(colnames(d2_list[[1]]),"ID")

traj_anim <- ggplot(data=float_frame,aes(x=time,y=y,group = ID))+
  coord_cartesian(ylim = c(-30,30))+
  geom_path(alpha = 0.25, size = 1)+
  #geom_point(alpha = 0.5)+
  comtheme+
  scale_color_viridis(discrete = F)+
  scale_fill_viridis(discrete = F)+
  labs(x = "time (s)", y = "Simulated Y position (micron)")

if (save_product){
  #anim_save(filename = paste(fname,".gif",sep=""),animaion = traj_anim, path = ".")
  ggsave(paste(fname,".png",sep=""),width = 30, height = 15, units = "cm")
}

```




